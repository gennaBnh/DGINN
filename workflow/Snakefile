from snakemake.utils import min_version, validate
min_version("7.15.2")

configfile: "config/config.json"
validate(config, "config/config.schema.yaml")

rule init:
    input: 
        config = "config/config.json"
    output:
        infile = config["data"]["o"]+config["parameters"]["step"]+"_"+[config["parameters"]["infile"]][0].split("/")[1]
    message: "Initializing pipeline, starting at step"+config["parameters"]["step"]+"."
    shell:
        "python3 scripts/Init.py {input.config} {output.infile}"


rule blast:
    input:
        infile = config["data"]["o"]+"blast_{samples}.fasta"
    output:
        tsvfile = config["data"]["o"]+"{samples}_blastres.tsv"
    params:
        config = "config/config.json"
    message: "Starting BLAST alignment on file {input.infile}, writing output in file {output.tsvfile}"
    shell:
        "python3 scripts/Blast.py {params.config} {output.tsvfile}"


rule extract:
    input:
        blastres = config["data"]["o"]+"{samples}_blastres.tsv" # à remplacer par config["data"]["o"]+"{samples}.tsv" car tous les fichiers d'entrée n'auront pas '_blastres'
    output:
        accns = "results/{samples}_accns.txt" #à modifier quand samples aura changé 
    params:
        config = "config/config.json"
    message: "Starting Accessions search from file {input.blastres}, writing accessions in file {output.accns}"
    shell:
        "python3 scripts/Extract.py {params.config} {input.blastres} {output.accns}"


rule fasta_res:
    input: 
        accns = "results/{samples}_accns.txt" #pareil que pour input extract 
    output:
        seq = "results/{samples}_sequences.fasta"
    params:
        config = "config/config.json"
    message: "Starting the retreival of FASTA sequences from accessions file {input.accns}, writing sequences in file {output.seq}"
    shell:
        "python3 scripts/fastaRes.py {params.config} {input.accns} {output.seq}"



rule get_orf:
    input:
        seqfile = "results/{samples}_sequences.fasta" #pareil que pour input extract 
    output:
        res = "results/{samples}_allORFs.fasta",
        res_longest = "results/{samples}_longestORFs.fasta"
    params:
        config = "config/config.json"
    message: "Starting ORFs search in FASTA sequences from file {input.seqfile}, writing longest ORFs found in file {output.res_longest}"
    shell:
        "python3 scripts/ORF.py {params.config} {output.res} {output.res_longest}"

rule align_mafft:
    input:
        lgst_ORFs = "results/{samples}_longestORFs.fasta"
    output:
        out_covAln = "results/{samples}_ORFs_al_mafft_clean.fasta"
    params:
        config = "config/config.json",
        out_mafft = "results/{samples}_ORFs_al_mafft.fasta"
    message: "Starting mafft nucleotide alignment. Aligning sequences from file {input.lgst_ORFs}, writing alignment in file {output.out_covAln}"
    run:
        shell("mafft --auto --quiet {input.lgst_ORFs} > {params.out_mafft}"),
        shell("python3 scripts/covAln.py {params.out_mafft} {output.out_covAln} {params.config}")


rule first_align_codon:
    input:
        in_alcodon = "results/{samples}_ORFs_al_mafft_clean.fasta" if config["parameters"]["align_nt"] else "results/{samples}_longestORFs.fasta"
    output:
        out_clusterIso = "results/{samples}_ORFs_alcodon_clustiso_first.fasta" if len(config["parameters"]["codon_aligner"]) == 2 else "results/{samples}_ORFs_alcodon_clustiso.fasta"
    params:
        config = "config/config.json",
        extension = config["parameters"]["codon_aligner"][0],
        out_codon_param = "results/{samples}_ORFs_alcodon",
        macse_param = "-prog refineAlignment -align" if config["parameters"]["align_nt"] else "-prog alignSequences -seq"
    message: "Starting first codon alignment with "+config["parameters"]["codon_aligner"][0]+" from file {input.in_alcodon}, writing results in file {output.out_clusterIso}" if len(config["parameters"]["codon_aligner"]) == 2 \
    else "Starting codon alignment with "+config["parameters"]["codon_aligner"][0]+" from file {input.in_alcodon}, writing results in file {output.out_clusterIso}"
    run:
        if config["parameters"]["codon_aligner"][0] == "prank" :
            shell("prank -d={input.in_alcodon} -o={params.out_codon_param}_{params.extension}.fas -codon -F"),
            shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}"),    #update de config["data"]["aln"] pour qu'il contienne le chemin
                                                                                                                                                    #vers le fichier de sortie de prank.
                                                                                                                                                    #Passage de {extension} pour verbose.
            shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

        elif config["parameters"]["codon_aligner"][0] == "macse" :
            shell("java -jar ../macse_v2.06.jar {params.macse_param} {input.in_alcodon} -out_NT {params.out_codon_param}_{params.extension}.fas"),
            shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
            shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

        else :
            print(f"Le paramètre codon_aligner du fichier config n'a pas été correctement rempli.\nIl doit contenir une liste d'au moins 1 élément et d'au plus 2.\nLes deux seules valeurs qu'il peut contenir sont \"macse\" ou \"prank\".\nIl contient actuellement la valeur {config['parameters']['codon_aligner']}")

rule second_align_codon:
    input:
        in_alcodon_2 = "results/{samples}_ORFs_alcodon_clustiso_first.fasta" if len(config["parameters"]["codon_aligner"]) == 2 else "results/{samples}_ORFs_alcodon_clustiso.fasta"
    output:
        out_clusterIso_2 = "results/{samples}_ORFs_alcodon_clustiso_final.fasta"
    params:
        config = "config/config.json",
        extension = config["parameters"]["codon_aligner"][1] if len(config["parameters"]["codon_aligner"]) == 2 else config["parameters"]["codon_aligner"][0],
        out_codon_param = "results/{samples}_ORFs_alcodon",
        macse_param = "-prog refineAlignment -align" if config["parameters"]["align_nt"] else "-prog alignSequences -seq"
    message: "Starting second codon alignment with "+config["parameters"]["codon_aligner"][1]+" from file {input.in_alcodon_2}, writing results in file {output.out_clusterIso_2}"


    run:
        if len(config["parameters"]["codon_aligner"]) == 1 :
            shell("mv results/{samples}_ORFs_alcodon_clustiso_first.fasta results/{samples}_ORFs_alcodon_clustiso_final.fasta") #Si un seul aligneur doit être lancé, la seule action de cette règle est de renommer le fichier de sortie.

        elif len(config["parameters"]["codon_aligner"]) == 2 :

            if config["parameters"]["codon_aligner"][1] == "prank" :
                shell("prank -d={input.in_alcodon_2} -o={params.out_codon_param}_{params.extension} -codon -F"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.best.fas {params.config} {params.extension}"),    #update de config["data"]["aln"] pour qu'il contienne le chemin
                                                                                                                                                    #vers le fichier de sortie de prank.
                                                                                                                                                    #Passage de {extension} pour verbose.
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso_2}")

            elif config["parameters"]["codon_aligner"][1] == "macse" :
                shell("java -jar ../macse_v2.06.jar {params.macse_param} {input.in_alcodon_2} -out_NT {params.out_codon_param}_{params.extension}.fas"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso_2}")
            else :
                print(f"Le paramètre codon_aligner du fichier config n'a pas été correctement rempli.\nIl doit contenir une liste d'au moins 1 élément et d'au plus 2.\nLes deux seules valeurs qu'il peut contenir sont \"macse\" ou \"prank\".\nIl contient actuellement la valeur {config['parameters']['codon_aligner']}")

        else :
            print(f"Le paramètre codon_aligner du fichier config n'a pas été correctement rempli.\nIl doit contenir une liste d'au moins 1 élément et d'au plus 2.\nLes deux seules valeurs qu'il peut contenir sont \"macse\" ou \"prank\".\nIl contient actuellement la valeur {config['parameters']['codon_aligner']}")
           
"""rule align:
    input:
        lgst_ORFs = "results/{samples}_longestORFs.fasta"
    output:
        out_covAln = "results/{samples}_ORFs_al_mafft_clean.fasta" if config["parameters"]["align_nt"] else "results/{samples}_longestORFs.fasta", #Testing if mafft alignment is required
        #out_codon = "results/{samples}_ORFs_alcodon_"+config["parameters"]["codon_aligner"]+".fas", #ajouter tree dans le nom
        out_clusterIso = "results/{samples}_ORFs_alcodon_clustiso.fasta" # Output final, à utiliser dans la suite 
    params:
        config = "config/config.json",
        out_mafft = "results/{samples}_ORFs_al_mafft.fasta",
        extension = config["parameters"]["codon_aligner"][0],                     # Seconde partie du nom de fichier de sortie
        out_codon_param = "results/{samples}_ORFs_alcodon"                       # Première partie du nom de fichier de sortie
    run:
    # Huit chemins sont possibles : mafft -> prank si align_nt = true et codon_aligner = ["prank"]
                                    # mafft -> macse si align_nt = true et codon_aligner = ["macse"]
                                    # prank seulement si align_nt = false et codon_aligner = ["prank"]
                                    # macse seulement si align_nt = false et codon_aligner = ["macse"]
                                    # mafft -> prank -> macse si align_nt = true et codon_aligner = ["prank", "macse"]
                                    # mafft -> macse -> prank si align_nt = true et codon_aligner = ["macse", "prank"]
                                    # prank -> macse si align_nt = false et codon_aligner = ["prank", "macse"]
                                    # macse -> prank si align_nt = false et codon_aligner = ["macse", "prank"]

        if config["parameters"]["align_nt"] :

            if config["parameters"]["codon_aligner"] == ["macse"] :
                # Exécution de mafft
                shell("mafft --auto --quiet {input.lgst_ORFs} > {params.out_mafft}"),
                shell("python3 scripts/covAln.py {params.out_mafft} {output.out_covAln} {params.config}")   #in1 : alignement mafft
                                                                                                            #in2 : fichier où covAln output
                                                                                                            #in3 : dictionnaire config
                                                                                                            # Data est update au sein de ce script
                # Exécution de macse
                shell("java -jar ../macse_v2.06.jar -prog refineAlignment -align {output.out_covAln} -out_NT {params.out_codon_param}_{params.extension}.fas"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

            elif config["parameters"]["codon_aligner"] == ["prank"] :
                # Exécution de mafft
                shell("mafft --auto --quiet {input.lgst_ORFs} > {params.out_mafft}"),
                shell("python3 scripts/covAln.py {params.out_mafft} {output.out_covAln} {params.config}")   #in1 : alignement mafft
                                                                                                            #in2 : fichier où covAln output
                                                                                                            #in3 : dictionnaire config
                                                                                                            # Data est update au sein de ce script
                # Exécution de prank
                shell("prank -d={output.out_covAln} -o={params.out_codon_param}_{params.extension}.fas -codon -F"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}")    #update de config["data"]["aln"] pour qu'il contienne le chemin
                                                                                                                                                        #vers le fichier de sortie de prank.
                                                                                                                                                        #Passage de {extension} pour verbose.
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

            elif config["parameters"]["codon_aligner"] == ["prank", "macse"] :
                # Exécution de mafft
                shell("mafft --auto --quiet {input.lgst_ORFs} > {params.out_mafft}"),
                shell("python3 scripts/covAln.py {params.out_mafft} {output.out_covAln} {params.config}"),   #in1 : alignement mafft
                                                                                                            #in2 : fichier où covAln output
                                                                                                            #in3 : dictionnaire config
                                                                                                            # Data est update au sein de ce script
                # Exécution de prank
                shell("prank -d={output.out_covAln} -o={params.out_codon_param}_{params.extension}.fas -codon -F"),                                                                                                                                                        #vers le fichier de sortie de prank.

                # Exécution de macse
                shell("java -jar ../macse_v2.06.jar -prog refineAlignment -align {params.out_codon_param}_{params.extension}.fas -out_NT {params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")


            elif config["parameters"]["codon_aligner"] == ["macse", "prank"] :
                # Exécution de mafft
                shell("mafft --auto --quiet {input.lgst_ORFs} > {params.out_mafft}"),
                shell("python3 scripts/covAln.py {params.out_mafft} {output.out_covAln} {params.config}"),   #in1 : alignement mafft
                                                                                                            #in2 : fichier où covAln output
                                                                                                            #in3 : dictionnaire config
                                                                                                            # Data est update au sein de ce script
                # Exécution de macse
                shell("java -jar ../macse_v2.06.jar -prog refineAlignment -align {output.out_covAln} -out_NT {params.out_codon_param}_{params.extension}.fas"),                

                # Exécution de prank
                shell("prank -d={params.out_codon_param}_{params.extension}.fas -o={params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas -codon -F"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
                                                                                                                                                                                                    #vers le fichier de sortie de prank.
                                                                                                                                                                                                    #Passage de {extension} pour verbose.
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

            else :

                print(f"Le paramètre codon_aligner du fichier config n'a pas été correctement rempli.\nIl doit contenir une liste d'au moins 1 élément et d'au plus 2.\nLes deux seules valeurs qu'il peut contenir sont \"macse\" ou \"prank\".\nIl contient actuellement la valeur {config['parameters']['codon_aligner']}")


        elif not config["parameters"]["align_nt"] :
            if config["parameters"]["codon_aligner"] == ["macse"] :
                # Exécution de macse
                shell("java -jar ../macse_v2.06.jar -prog alignSequences -seq {input.lgst_ORFs} -out_NT {params.out_codon_param}_{params.extension}.fas"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

            elif config["parameters"]["codon_aligner"] == ["prank"] :
                #Exécution de prank
                shell("prank -d={input.lgst_ORFs} -o={params.out_codon_param}_{params.extension}.fas -codon -F"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}.fas {params.config} {params.extension}")    #update de config["data"]["aln"] pour qu'il contienne le chemin
                                                                                                                                                        #vers le fichier de sortie de prank.
                                                                                                                                                        #Passage de {extension} pour verbose.
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")

            elif config["parameters"]["codon_aligner"] == ["prank", "macse"] :
                #Exécution de prank
                shell("prank -d={input.lgst_ORFs} -o={params.out_codon_param}_{params.extension}.fas -codon -F"),

                #Exécution de macse
                shell("java -jar ../macse_v2.06.jar -prog alignSequences -seq {params.out_codon_param}_{params.extension}.fas -out_NT {params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas {params.config} {params.extension}"),  #update de config["data"]["aln"] pour qu'il contienne le chemin
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")
            
            elif config["parameters"]["codon_aligner"] == ["macse", "prank"] :
                #Exécution de macse
                shell("java -jar ../macse_v2.06.jar -prog alignSequences -seq {input.lgst_ORFs} -out_NT {params.out_codon_param}_{params.extension}.fas"),

                #Exécution de prank
                shell("prank -d={params.out_codon_param}_{params.extension}.fas -o={params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas -codon -F"),
                shell("python3 scripts/config_update_alcodon.py {params.out_codon_param}_{params.extension}_"+config["parameters"]["codon_aligner"][1]+".fas {params.config} {params.extension}")   #update de config["data"]["aln"] pour qu'il contienne le chemin
                                                                                                                                                                                                    #vers le fichier de sortie de prank.
                                                                                                                                                                                                    #Passage de {extension} pour verbose.
                shell("python3 scripts/clusterIso.py {params.config} {output.out_clusterIso}")
            else :
                print(f"Le paramètre codon_aligner du fichier config n'a pas été correctement rempli.\nIl doit contenir une liste d'au moins 1 élément et d'au plus 2.\n\
                Les deux seules valeurs qu'il peut contenir sont \"macse\" ou \"prank\".\nIl contient actuellement la valeur : {config['parameters']['codon_aligner']}")
        else :
            print(f"Le paramètre align_nt du fichier config n'a pas été correctement rempli.\nIl doit contenir un booléen.\nIl contient actuellement la valeur : {config['parameters']['align_nt']}")
"""
"""
rule tree:
    input:
        infile = "results/ex_CCDS_ORFs_alcodon_clustiso.fasta" #ajouter tree dans le nom
    params:
        fonction = "phyMLTree",
        config = "config/config.json"
    output:
        phymlfile = config["data"]["o"]+config["data"]["aln"].split("/")[-1].split(".")[0]+".phylip_phyml_tree.txt"
    shell:
        "python3 scripts/Analysis.py {params.config} {params.fonction}"


rule duplication:
    input:
        infile = "results/ex_CCDS_ORFs_alcodon_clustiso.fasta", #ajouter duplication dans le nom
        infile_tree = config["data"]["dAlTree"][config["data"]["aln"]]
    params:
        fonction = "checkPhyMLTree",
        config = "config/config.json"
    output:
        output_nhx = config["data"]["dAlTree"][config["data"]["aln"]]+"_recs.nhx",
        output_svg = config["data"]["dAlTree"][config["data"]["aln"]]+"_recs.svg"
    shell:
        "python3 scripts/Analysis.py {params.config} {params.fonction}"


rule recombination:
    input:
        config = "config/config.json"
    params:
        fonction = "gardRecomb",
        config = "config/config.json"
    output:
    	gardRes =  config["data"]["o"]+config["data"]["aln"].split("/")[-1].split(".")[0]+".gard",
	    gardJson = config["data"]["o"]+config["data"]["aln"].split("/")[-1]+".GARD.json"
    shell:
        "python3 scripts/Analysis.py {params.config} {params.fonction}"

rule positive_selection:
    input:
        config = "config/config.json"
    output:
	    pos_res = config["data"]["o"]+"files_list.txt"
    shell:
        "python3 scripts/posSel.py {input.config}
"""