from snakemake.utils import min_version, validate

min_version("7.15.2")

configfile: "config.json"
validate(config, "config.schema.yaml")


rule init:
    input: 
        param = config["parameters"],
        infile = config["infile"]
    params:
        query = config["queryName"],
        outdir = config["outdir"],
        hostfile = config["hostfile"]
    output:
        dico_data_update = temp("results/data.pkl"),
        dico_params_update = temp("results/params.pkl")
    shell:
        "python3 scripts/init_test.py -p {input.param} -i {input.infile}" #input pas obligatoire donc comment on fait 
# to do : init for json = seulement la fonction qui parse queryName ? 

rule blast:
    input: 
        dico_params = "results/params.pkl", #ne va pas parce que j'aurai ça dans tous les cas
        dico_data = "results/data.pkl" #ne va pas 
    output:
        dico_data_update = temp("results/data_blast.pkl"), # ne vas pas
        dico_params_update = "results/params_blast.pkl" #ne va pas 
    shell:
        "python3 scripts/blast_test.py {input.dico_params} {input.dico_data} {output.dico_data_update} {output.dico_params_update}"


rule extract:
    input: 
        dico_data = "results/data_blast.pkl"
    output:
        dico_data_update = temp("results/data_extract.pkl"),
        accns = "results/accns.txt"
    shell:
        "python3 scripts/extract_test.py {input.dico_data} {output.accns} {output.dico_data_update}"


rule fasta_res:
    input: 
        dico_params = "results/params_blast.pkl",
        dico_data = "results/data_extract.pkl"
    output:
        dico_data_update = "results/data_fastaRes.pkl",
        seq = "results/sequences.fasta"
    shell:
        "python3 scripts/fastares_test.py {input.dico_params} {input.dico_data} {output.seq} {output.dico_data_update}"

rule get_orf:
    input:
        dico_data = "results/data_fastaRes.pkl"
    output:
        res = "results/allORFs.fasta",
        res_longest= "results/longestORFs.fasta",
        data_update = "results/data_getorf.pkl"
    shell:
        "python3 scripts/orf_test.py {input.dico_data} {output.res} {output.res_longest} {output.data_update}"

# Pour l'instant, le choix de l'aligneur se fait en fonction du nom de fichier output :
# Si le nom d'output est results/ORFs_align_codon_prank.fas, la règle align_prank devrait être lancée
# Si le nom d'output est results/ORFs_align_codon_macse.fas, la règle align_macse devrait être lancée.

rule align_prank: 
    input:
        dico_data = "results/data_getorf.pkl",
        lgst_ORFs = "results/longestORFs.fasta"
    output:
        out_codon = "results/ORFs_align_codon_{extension}.fas",
        out_mafft = "results/ORFs_align_mafft.fasta",
        out_covAln = "results/ORFs_align_mafft_clean.fasta",
        data_update_mafft = "results/data_mafft.pkl",
        data_update_codon = "results/data_prank.pkl"
    params:
        extension = data["codon_aligner"]
    run:
        shell("mafft --auto --quiet {input.lgst_ORFs} > {output.out_mafft}"),
        shell("python3 scripts/covAln_test.py {output.out_mafft} {output.out_covAln} {input.dico_data} {output.data_update_mafft}"), #in1 : alignement donné en output de mafft
                                                                                                                                    #in2 : fichier où covAln output
                                                                                                                                    #in3 : dictionnaire data
                                                                                                                                    # Data est update au sein de ce script
        shell("prank -d={output.out_covAln} -o={output.out_codon}_{params.extension}.fas -codon -F"),
        shell("python3 scripts/data_update_prank.py {output.out_codon}_{params.extension}.fas {output.data_update_mafft} {output.data_update_codon}") #update de data["aln"] pour qu'il contienne le chemin
                                                                                                    #vers le fichier de sortie de prank.

rule align_macse: 
    input:
        dico_data = "results/data_getorf.pkl",
        lgst_ORFs = "results/longestORFs.fasta"
    output:
        out_codon = "results/ORFs_align_codon_{extension}.fas",
        out_mafft = "results/ORFs_align_mafft.fasta",
        out_covAln = "results/ORFs_align_mafft_clean.fasta",
        data_update_mafft = "results/data_mafft.pkl",
        data_update_codon = "results/data_prank.pkl"
    params:
        extension = data["codon_aligner"]
    run:
        shell("mafft --auto --quiet {input.lgst_ORFs} > {output.out_mafft}"),
        shell("python3 scripts/covAln_test.py {output.out_mafft} {output.out_covAln} {input.dico_data} {output.data_update_mafft}"), #in1 : alignement donné en output de mafft
                                                                                                                                    #in2 : fichier où covAln output
                                                                                                                                    #in3 : dictionnaire data
                                                                                                                                    # Data est update au sein de ce script
        shell("java -jar ../../macse_v2.06.jar -prog refineAlignment -align {output.out_covAln} -out_NT {output.out_codon}_{params.extension}.fas"),
        shell("python3 scripts/data_update_prank.py {output.out_codon}_{params.extension}.fas {output.data_update_mafft} {output.data_update_codon}") #update de data["aln"] pour qu'il contienne le chemin
                                                                                                    #vers le fichier de sortie de prank.
